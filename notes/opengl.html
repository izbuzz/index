<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-01-13" />
  <title>OpenGL</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../style.css" />
<link rel="stylesheet" href="../light.css" media="(prefers-color-scheme: light)">
<link rel="stylesheet" href="../dark.css" media="(prefers-color-scheme: dark)">
<script src="../dark.js"></script>
<script src="../toggle.js" defer></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="dark.js" async defer></script>
</head>
<body>
  <nav class="row row-gap row-start row-stretch" id="nav_margin">
    <div class="row">
      <div class="medium_spacer space_navbar"></div>
      <div>&nbsp;</div>
      <div class="small_spacer space_navbar"></div>
    </div>
    <a class="flatbutton row row-start" href="../index.html">
      <div class="square_icon"></div><div>HOME</div>
    </a>
    <a class="flatbutton row row-start" href="../archive.html">
      <div class="square_icon"></div><div>ARCHIVE</div>
    </a>
    <a class="flatbutton row row-start" href="../notes.html" aria-current="page">
      <div class="square_icon"></div><div>NOTES</div>
    </a>
    <a class="flatbutton row row-start" href="../about.html">
      <div class="square_icon"></div><div>ABOUT</div>
    </a>
    <button id="toggle_theme" class="row align_self_end" aria-label="Cycle between light, auto, and dark theme">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon auto" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><circle cx="128" cy="128" r="96" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="128" y1="32" x2="128" y2="224" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="192" y1="56.45" x2="192" y2="199.55" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="160" y1="37.47" x2="160" y2="218.53" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/></svg>
      <svg xmlns="http://www.w3.org/2000/svg" class="icon sun" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><path d="M120,40V16a8,8,0,0,1,16,0V40a8,8,0,0,1-16,0Zm8,24a64,64,0,1,0,64,64A64.07,64.07,0,0,0,128,64ZM58.34,69.66A8,8,0,0,0,69.66,58.34l-16-16A8,8,0,0,0,42.34,53.66Zm0,116.68-16,16a8,8,0,0,0,11.32,11.32l16-16a8,8,0,0,0-11.32-11.32ZM192,72a8,8,0,0,0,5.66-2.34l16-16a8,8,0,0,0-11.32-11.32l-16,16A8,8,0,0,0,192,72Zm5.66,114.34a8,8,0,0,0-11.32,11.32l16,16a8,8,0,0,0,11.32-11.32ZM48,128a8,8,0,0,0-8-8H16a8,8,0,0,0,0,16H40A8,8,0,0,0,48,128Zm80,80a8,8,0,0,0-8,8v24a8,8,0,0,0,16,0V216A8,8,0,0,0,128,208Zm112-88H216a8,8,0,0,0,0,16h24a8,8,0,0,0,0-16Z"/></svg>
      <svg xmlns="http://www.w3.org/2000/svg" class="icon moon" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><path d="M235.54,150.21a104.84,104.84,0,0,1-37,52.91A104,104,0,0,1,32,120,103.09,103.09,0,0,1,52.88,57.48a104.84,104.84,0,0,1,52.91-37,8,8,0,0,1,10,10,88.08,88.08,0,0,0,109.8,109.8,8,8,0,0,1,10,10Z"/></svg>
    </button>
  </nav>
<main class="content">
<header id="title-block-header">
<h1 class="title">OpenGL</h1>
<div class="date row row-start">
<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><rect x="40" y="40" width="176" height="176" rx="8" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="176" y1="24" x2="176" y2="56" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="80" y1="24" x2="80" y2="56" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="40" y1="88" x2="216" y2="88" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="132" r="12"/><circle cx="172" cy="132" r="12"/><circle cx="84" cy="172" r="12"/><circle cx="128" cy="172" r="12"/><circle cx="172" cy="172" r="12"/></svg>
<div>&nbsp;</div>
<p>
2025-01-13
</p>
</div>
</header>
<h1 id="opengl">OpenGL</h1>
<p>Yada yada graphics API, communicates with GPU, blah blah. Under the
hood it is a state engine, which is why there are all these binds,
unbinds and sets. This is kind of bad, because state is bad, and so
later OpenGL versions and Vulkan try to move away from state and avoid
this bind, unbind loop.</p>
<p>In fact, recent OpenGL versions have Direct State Access where the
caller can perform a set operation without binding and unbinding the
target. This text will be using the Direct State Access variant for as
many of the OpenGL functions here as possible.</p>
<h2 id="startup">Startup</h2>
<p>Unlike Vulkan, to obtain a OpenGL context, we need a window. So we
open up a window and obtain one, either manually or through something
like SDL or GLFW. Now we can start GL-ing.</p>
<p>Actually, before that, we need to load OpenGL functions for the given
platform using something called a wrangler, the most modern option seems
to be GLAD.</p>
<p>Debug outputs can help a lot for … debugging.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>glEnable<span class="op">(</span>GL_DEBUG_OUTPUT<span class="op">);</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>glDebugMessageCallback<span class="op">(</span>callback<span class="op">,</span> <span class="kw">nullptr</span><span class="op">);</span></span></code></pre></div>
<p>Where a callback is of the form</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> callback<span class="op">(</span>GLenum source<span class="op">,</span> GLenum type<span class="op">,</span> GLuint id<span class="op">,</span> GLenum severity<span class="op">,</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>              GLsizei length<span class="op">,</span> <span class="dt">const</span> GLchar<span class="op">*</span> message<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span><span class="op">*</span>  user_param<span class="op">)</span></span></code></pre></div>
<h2 id="shaders-and-programs">Shaders and Programs</h2>
<p>Shaders are just fancy term for code run in a graphics pipeline. A
program is a collection of shaders linked and ready to render.</p>
<p>The code without error handling is along the lines of</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>GLuint program <span class="op">=</span> glCreateProgram<span class="op">();</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>GLuint shader <span class="op">=</span> glCreateShader<span class="op">(</span>GL_VERTEX_SHADER<span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Repeat for each shader type</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>glShaderSource<span class="op">(</span>shader<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="op">&amp;</span>data<span class="op">,</span> <span class="op">&amp;</span>size<span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>glCompileShader<span class="op">(</span>shader<span class="op">);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>glAttachShader<span class="op">(</span>program<span class="op">,</span> shader<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>glLinkProgram<span class="op">(</span>program<span class="op">);</span></span></code></pre></div>
<p>See the <code>GL_VERTEX_SHADER</code>? There are different types of
shaders which run in different points of the graphics pipeline. After
binding the program with <code>glUseProgam(progam)</code>, we are ready
to render… except what are we rendering?</p>
<h2 id="buffers">Buffers</h2>
<p>The concept of buffers here is not really all that different, they
just store data, except in the memory allocated by the GPU. As usual,
they are unformatted.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>GLuint buffer <span class="op">=</span> GL_NONE<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>glCreateBuffers<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">&amp;</span>buffer<span class="op">);</span></span></code></pre></div>
<p>Now that we have a buffer, we can pass some data to it. Note that we
have to pass in the size of the passed in data, which can be an array or
vector, not its length.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// non-fixed size</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>glNamedBufferData<span class="op">(</span>buffer<span class="op">,</span> size<span class="op">,</span> <span class="op">*</span>data<span class="op">,</span> flags<span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">// fixed size, more performance</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>glNamedBufferStorage<span class="op">(</span>buffer<span class="op">,</span> size<span class="op">,</span> <span class="op">*</span>data<span class="op">,</span> flags<span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">// to update data</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>glNamedBufferSubData<span class="op">(</span>buffer<span class="op">,</span> size<span class="op">,</span> <span class="op">*</span>data<span class="op">,</span> flags<span class="op">);</span></span></code></pre></div>
<p>There are a lot of other ways to update and set data, all with their
pros and caveats. Anyways, this data is unformatted right? How are you
suppose to render with a random stream of data?</p>
<h2 id="vertex-arrays">Vertex Arrays</h2>
<p>We can solve the unformatted data issue by passing in pre-formatted
data and telling OpenGL how it is formatted. Kind of boring, right?
There is now also something called vertex pulling to avoid this vertex
array, but that has its own implications.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>GLuint vao <span class="op">=</span> GL_NONE<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>glCreateVertexArrays<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">&amp;</span>vao<span class="op">);</span></span></code></pre></div>
<p>If our data is formatted as a vertex as follows</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vertex <span class="op">{</span> vec3 pos<span class="op">;</span> vec3 normal<span class="op">;</span> vec2 uv <span class="op">};</span></span></code></pre></div>
<p>There are clearly three variables, or in OpenGL-land, attributes, so
we should OpenGL that,</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>glEnableVertexArrayAttrib<span class="op">(</span>vao<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>glEnableVertexArrayAttrib<span class="op">(</span>vao<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>glEnableVertexArrayAttrib<span class="op">(</span>vao<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<p>And then the format in detail, including the offsets</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>glVertexArrayAttribFormat<span class="op">(</span>vao<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> GL_FLOAT<span class="op">,</span> GL_FALSE<span class="op">,</span> offsetof<span class="op">(</span>Vertex<span class="op">,</span> pos<span class="op">));</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>glVertexArrayAttribFormat<span class="op">(</span>vao<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> GL_FLOAT<span class="op">,</span> GL_FALSE<span class="op">,</span> offsetof<span class="op">(</span>Vertex<span class="op">,</span> normal<span class="op">));</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>glVertexArrayAttribFormat<span class="op">(</span>vao<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> GL_FLOAT<span class="op">,</span> GL_FALSE<span class="op">,</span> offsetof<span class="op">(</span>Vertex<span class="op">,</span> uv<span class="op">));</span></span></code></pre></div>
<p>And no we have to enable the binding, weird huh,</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>glVertexArrayAttribBinding<span class="op">(</span>vao<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>glVertexArrayAttribBinding<span class="op">(</span>vao<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>glVertexArrayAttribBinding<span class="op">(</span>vao<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>Afterwards we have to bind this along with the buffers we created
earlier, so OpenGL knows which vertex array describes which set of
buffers</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>glBindVertexArray<span class="op">(</span>vao<span class="op">);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>glVertexArrayVertexBuffer<span class="op">(</span>vao<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> vbo<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Vertex<span class="op">));</span></span></code></pre></div>
<p>If we also want to bind a buffer which stores only the indices of the
vertices to be rendered in order to de-duplicate duplicate vertices, for
example.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>glVertexArrayElementBuffer<span class="op">(</span>vao<span class="op">,</span> ebo<span class="op">);</span></span></code></pre></div>
<p>Note we can actually rebind other buffers to the bound vertex array
afterwards. And no we can render, right?</p>
<h2 id="rendering">Rendering</h2>
<p>This section is about rendering, but not how to render, boo. Okay,
there are a couple of different “models” of rendering</p>
<ul>
<li>regular</li>
<li>indexed</li>
<li>instancing</li>
</ul>
<p>Regular is the simplest, drawing whatever is in the buffer using
something like triangles, strips, rectangles, whatever. Index takes a
step up and draws vertices based on indices and connects them. And
instancing uses GPU voodoo magic to draw a set of the same model, mesh,
shape, whatever efficiently.</p>
<p>The indexed and instancing models can be used together and there are
different variants to tune how you index the instances. If the function
takes indices, it is using indexed draw, if it takes arguments like
<code>instancecount</code>, it uses instancing. If it has both, then it
uses both.</p>
<h2 id="draw-commands">Draw Commands</h2>
<p>Newer OpenGL has something called draw commands, where we can
directly submit a buffer of draw commands to the GPU instead of submit
them one by one. Besides being able to pack multiple related draw
commands in one go, this paves the way for generating draw commands in
another buffer ahead of time, where the current draw buffer is executed.
Then the new draw buffer can be submitted while another one is being
prepared.</p>
<p>This one is for glMultiDrawElements, as evident by index and
base_instance.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> DrawCommand <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span><span class="dt">uint32_t</span> count<span class="op">;</span>        <span class="co">// how many indices</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span><span class="dt">uint32_t</span> instance_count<span class="op">;</span>   <span class="co">// how many instances to draw</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span><span class="dt">uint32_t</span> first_index<span class="op">;</span>  <span class="co">// offset to the first indice</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span><span class="dt">int32_t</span> base_vertex<span class="op">;</span>   <span class="co">// offset to the first vertex</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    std<span class="op">::</span><span class="dt">uint32_t</span> base_instance<span class="op">;</span>    <span class="co">// offset for when drawing multiple instances</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>We can add these commands to a buffer similar to the vertices from
before</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>GLuint cmd_buffer<span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>glCreateBuffers<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">&amp;</span>buffer<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>glNamedBufferStorage<span class="op">(</span>cmd_buffer<span class="op">,</span> command_vector_size<span class="op">,</span> <span class="op">*</span>data<span class="op">,</span> flags<span class="op">);</span></span></code></pre></div>
<p>And then binding it and performing the draw</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>glBindBuffer<span class="op">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="op">,</span> index_buffer<span class="op">);</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>glBindBuffer<span class="op">(</span>GL_DRAW_INDIRECT_BUFFER<span class="op">,</span> cmd_buffer<span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>glMultiDrawElementsIndirect<span class="op">(</span>GL_TRIANGLES<span class="op">,</span> GL_UNSIGNED_INT<span class="op">,</span> offset<span class="op">,</span> cmd_vector_len<span class="op">,</span> stride<span class="op">);</span></span></code></pre></div>
<p>We can draw now! But what exactly are we going to draw?</p>
<h2 id="gltf">glTF</h2>
<p>glTF is a file format for specifying a scene, which turns out to have
all the information needed to render said scene. And in binary format,
too, for performance. There are other details like skin, animation,
camera, and sampler which will be ignored for now in favor of the
geometry.</p>
<h3 id="nodes">Nodes</h3>
<p>The scene is composed of nodes, which can hold children nodes, and
more importantly a mesh. Any of the root nodes can be thought of as the
subject to be rendered. The node can hold transformation information,
such as position, rotation, and scale.</p>
<p>Why nodes instead of just meshes? A model may have duplicate meshes,
like the wheels of a car, and instead of respecifying the mesh, the
format can represent it as a child node with a different position
instead.</p>
<h3 id="meshes">Meshes</h3>
<p>A mesh is just a list of primitives. Primitives can be a point, line
or triangle. It contains</p>
<ul>
<li>indices</li>
<li>attributes, like normal, position, and texture coordinates</li>
<li>material</li>
</ul>
<p>Note that these values are not the values themselves, but rather an
index to a buffer stored by the glTF. These values then index accessors.
And long story short, these accessors index buffer views which segment
the buffers and gives the actual values.</p>
<p>Oh and there is also a sparse accessors which is different from the
default one. And also primitives can be morphed or deformed, by
specifying a morph target. Not getting into that.</p>
<h3 id="materials">Materials</h3>
<p>Bet you glazed over the materials part of the primitive, well here it
is. Materials define roughly how the primitive should look, in terms of
lighting and texture. Lighting is defined using the PBR, physically
based rendering model, and describes a whole set of properties important
for lighting.</p>
<p>The primitive can either use a texture to define its color in
addition to RGB scaling values. Ummm, read the specs, basically</p>
<ul>
<li>baseColorFactor: scaling for RGB, used as color if baseColorTexture
is missing</li>
<li>metallicFactor: scaling for metalness in blue channel, substitutes
metallicRoughnessFactorTexture</li>
<li>roughnessFactor: scaling for metalness in green channel, substitutes
metallicRoughnessFactorTexture</li>
<li>normalTexture</li>
<li>occulsionTexture</li>
<li>emmisiveTexture</li>
</ul>
<p>The textures point to the index the texture in a buffer, similar to
the story with the mesh and geometry. There can also be multiple
textures to be bound in a property.</p>
<h3 id="textures">Textures</h3>
<p>Pretty much just an image… yes. This can point to a file via a URI,
or the actual buffer data. There is also sampling information for how to
sample it, the sampler in question being the OpenGL texture
samplers.</p>
<h3 id="extensions-skins-cameras-animation">Extensions, Skins, Cameras,
Animation</h3>
<p>We are not doing this, skip, skip skip!</p>
<h2 id="renderer-design">Renderer Design</h2>
<p>Must haves</p>
<ul>
<li>Multiple programs, for different forms of rendering</li>
<li>Singular VAO, or keep it as little as possible, format should not
vary that much</li>
<li>Scenegraph, whether as a list or tree</li>
<li>nodes represented as glTF nodes, generally, but can be other things
too</li>
<li>mesh should have draw command buffers, vertex buffers, and index
buffers, and materials</li>
<li>sort draws base on materials</li>
<li>primitives should hold indices to command buffers</li>
</ul>
<p>Nice to haves</p>
<ul>
<li>UI via IMgui</li>
<li>async and concurrency</li>
<li>ECS</li>
<li>hot reload</li>
</ul>
<h2 id="links">Links</h2>
<h3 id="opengl-1">OpenGL</h3>
<p>https://github.com/fendevel/Guide-to-Modern-OpenGL-Functions?tab=readme-ov-file#faster-reads-and-writes-with-persistent-mapping
https://ktstephano.github.io/
https://nlguillemot.wordpress.com/2016/11/18/opengl-renderer-design/
https://www.khronos.org/opengl/wiki/Buffer_Object_Streaming</p>
<h3 id="renderer-design-1">Renderer Design</h3>
<p>https://bitsquid.blogspot.com/2017/02/stingray-renderer-walkthrough.html
https://ruby0x1.github.io/machinery_blog_archive/</p>
</main>
</body>
</html>
