<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-01-13" />
  <title>Linux Graphics</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="dark.js" async defer></script>
</head>
<body>
  <nav class="row row-gap row-start row-stretch" id="nav_margin">
    <div class="row">
      <div class="medium_spacer space_navbar"></div>
      <div>&nbsp;</div>
      <div class="small_spacer space_navbar"></div>
    </div>
    <a class="flatbutton row row-start" href="../index.html">
      <div class="square_icon"></div><div>HOME</div>
    </a>
    <a class="flatbutton row row-start" href="../notes.html" aria-current="page">
      <div class="square_icon"></div><div>ARCHIVE</div>
    </a>
    <a class="flatbutton row row-start" href="../notes.html">
      <div class="square_icon"></div><div>NOTES</div>
    </a>
    <a class="flatbutton row row-start" href="../about.html">
      <div class="square_icon"></div><div>ABOUT</div>
    </a>
    <label id="colorlabel" class="row align_self_end" for="colorswitch">
      <input id="colorswitch" type="checkbox" name="colorswitch">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon sun" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><path d="M120,40V16a8,8,0,0,1,16,0V40a8,8,0,0,1-16,0Zm8,24a64,64,0,1,0,64,64A64.07,64.07,0,0,0,128,64ZM58.34,69.66A8,8,0,0,0,69.66,58.34l-16-16A8,8,0,0,0,42.34,53.66Zm0,116.68-16,16a8,8,0,0,0,11.32,11.32l16-16a8,8,0,0,0-11.32-11.32ZM192,72a8,8,0,0,0,5.66-2.34l16-16a8,8,0,0,0-11.32-11.32l-16,16A8,8,0,0,0,192,72Zm5.66,114.34a8,8,0,0,0-11.32,11.32l16,16a8,8,0,0,0,11.32-11.32ZM48,128a8,8,0,0,0-8-8H16a8,8,0,0,0,0,16H40A8,8,0,0,0,48,128Zm80,80a8,8,0,0,0-8,8v24a8,8,0,0,0,16,0V216A8,8,0,0,0,128,208Zm112-88H216a8,8,0,0,0,0,16h24a8,8,0,0,0,0-16Z"/></svg>
      <svg xmlns="http://www.w3.org/2000/svg" class="icon moon" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><path d="M235.54,150.21a104.84,104.84,0,0,1-37,52.91A104,104,0,0,1,32,120,103.09,103.09,0,0,1,52.88,57.48a104.84,104.84,0,0,1,52.91-37,8,8,0,0,1,10,10,88.08,88.08,0,0,0,109.8,109.8,8,8,0,0,1,10,10Z"/></svg>
      <svg xmlns="http://www.w3.org/2000/svg" class="icon system" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><circle cx="128" cy="128" r="96" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="128" y1="32" x2="128" y2="224" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="192" y1="56.45" x2="192" y2="199.55" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="160" y1="37.47" x2="160" y2="218.53" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/></svg>
    </label>
  </nav>
<main class="content">
<header id="title-block-header">
<h1 class="title">Linux Graphics</h1>
<div class="date row row-start">
<svg xmlns="http://www.w3.org/2000/svg" class="icon" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"/><rect x="40" y="40" width="176" height="176" rx="8" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="176" y1="24" x2="176" y2="56" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="80" y1="24" x2="80" y2="56" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><line x1="40" y1="88" x2="216" y2="88" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"/><circle cx="128" cy="132" r="12"/><circle cx="172" cy="132" r="12"/><circle cx="84" cy="172" r="12"/><circle cx="128" cy="172" r="12"/><circle cx="172" cy="172" r="12"/></svg>
<div>&nbsp;</div>
<p>
2025-01-13
</p>
</div>
</header>
<h1 id="linux-graphics">Linux Graphics</h1>
<ol type="1">
<li>graphics api: Vulkan, OpenGL, etc…</li>
<li>drm: Manages memory, both shared and graphics memory, allows
allocating, querying and moving memory buffers</li>
<li>mesa: Provides framework and implementations of graphics api and
interacts with drm</li>
<li>compositing: X or wayland, draws output buffers to screens and
responsible for gathering user input for the application.</li>
</ol>
<h2 id="wayland">Wayland</h2>
<p>Wayland can use software rendering or hardware rendering, using
dma-buf, for rendering images. Dma-buf allows application and the
compositor to read and access the rendered images, instead of having it
sent over a hardware bus after storing it in shared memory. However,
since we cannot tell if the hardware has finished rendering, so an
operation called fencing is used as a signal.</p>
<p>After the image is rendered, the compositor prints it to the screen
in a series of steps:</p>
<ol type="1">
<li>drm framebuffer: A buffer which stores the image, along with its
size and color format</li>
<li>scanout: The framebuffer’s pixel data is read into one or multiple
scanout buffers depending on the format</li>
<li>cathode-ray tube controller (CRTC): Reads pixels from the scanout
buffer. More specifically, it reads pixels from a plane. A plane encodes
a scanout buffers position, orientation, and scaling. This is required
because a framebuffer could be smaller or larger than the screen,
resulting in multiple active planes, especially when considering
multi-monitor configurations. The planes can overlap, so the CRTC is
responsible for blending them and then forwarding them to ouputs, which
are made of encoders and connectors.</li>
<li>encoders: encodes pixel data for a specifc connector</li>
<li>connectors: physical connection to a device, such as HDMI or
VGA</li>
</ol>
<p>There can be mutiple framebuffers as well, and therefore multiple
scanout buffers. For example, there can be a framebuffer and scanout for
the cursor, window, taskbar, overlays.</p>
<p>When first rendering, the compositor sets up the pipeline: creating
framebuffers, attaching planes, setting display mode for CRTC, and then
connecting the stages. Afterwards, updating the image merely requires
changing the framebuffer, a process called page flipping.</p>
<p>However the stage linking can be done in many ways, CRTC to multiple
outputs, or framebuffer to multiple CRTCs. In such cases, individually
connecting each stage without verifying can lead to an invalid pipeline
configuration and thus issues with page flips or switching modes. To
solve this, DRM provides a atomic mode setting which verifies the
configuration is valid before applying changes such as page flips.</p>
<h2 id="references">References</h2>
<p><a href="https://lwn.net/Articles/955376/">The Linux graphics stack
in a nutshell, part 1</a> <a href="https://lwn.net/Articles/955708/">The
Linux graphics stack in a nutshell, part 2</a></p>
<p><a href="https://lwn.net/Articles/653071/">Atomic mode setting design
overview, part 1</a> <a href="https://lwn.net/Articles/653466/">Atomic
mode setting design overview, part 2</a></p>
</main>
</body>
</html>
